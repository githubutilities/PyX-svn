\chapter{Module canvas: PostScript interface}

\label{canvas}

\section{Class canvas}

The basic module for the PostScript access in \PyX{} is named
\verb|canvas|. Its main purpose is to provide the class \verb|canvas|,
which presents a collection of visual elements like paths, other
canvases, \TeX{} or \LaTeX{} elements. Eventually, the contents of a canvas 
can be written to a (E)PS file to produce the desired output.

\subsection{Basic usage}

The main \verb|canvas| instance, which we shall by convention always
name \verb|c|, will usually be constructed without giving any
arguments:
\begin{quote}
\begin{verbatim}
import pyx

c = canvas.canvas()
\end{verbatim}
\end{quote}
Basic drawing proceeds then via the construction of a \verb|path|, which 
can subsequently be drawn on the canvas using the method \verb|draw()|:
\begin{quote}
\begin{verbatim}
p = path.line(0, 0, 10, 10)
c.draw(p)
\end{verbatim}
\end{quote}
or more concisely:
\begin{quote}
\begin{verbatim}
c.draw(path.line(0, 0, 10, 10))
\end{verbatim}
\end{quote}
You can modify the appearance of a path by additionally passing 
instances of the class \verb|PathStyle|. For instance, you can draw the 
the above path \verb|p| in blue, as well:
\begin{quote}
\begin{verbatim}
c.draw(p, color.rgb.blue)
\end{verbatim}
\end{quote}
Similarly, it is possible to draw a dashed version of \verb|p|:
\begin{quote}
\begin{verbatim}
c.draw(p, canvas.linestyle.dashed)
\end{verbatim}
\end{quote}
Combining of several \verb|PathStyle|s is of course also possible:
\begin{quote}
\begin{verbatim}
c.draw(p, color.rgb.blue, canvas.linestyle.dashed)
\end{verbatim}
\end{quote}
Furthermore, drawing an arrow at the begin or end of the path is done
in a similar way. You just have to use the provided \verb|barrow| and 
\verb|earrow| instances:
\begin{quote}
\begin{verbatim}
c.draw(p, canvas.barrow.normal, canvas.earrow.large)
\end{verbatim}
\end{quote}

Filling of a path is possible via the \verb|fill| method of the canvas.
Let us for example draw a filled rectangle 
\begin{quote}
\begin{verbatim}
r = path.rect(0, 0, 10, 5)
c.fill(r)
\end{verbatim}
\end{quote}
Alternatively, you can use the class \verb|filled| of the canvas module
in combination with the \verb|draw| method:
\begin{quote}
\begin{verbatim}
c.draw(r, canvas.filled())
\end{verbatim}
\end{quote}

To conclude the section on the drawing of paths, we consider a pretty
sophisicated combination of the above presented \verb|PathStyle|s:
\begin{quote}
\begin{verbatim}
c.draw(p, 
       color.rgb.blue, 
       canvas.earrow.LARge(color.rgb.red,
                           canvas.stroked(canvas.linejoin.round),
                                          canvas.filled(color.rgb.green)))
                                                              
\end{verbatim}
\end{quote}
This draws the path in blue with a pretty large arrow at the end, the outline
of which is red and rounded and which is filled with green.

After you are finished with the composition of your canvas, you can
write it to a file using the method \verb|writetofile()|. It expects the
obligatory argument \verb|filename|, the name of the output
file. To write your results to the file "test.eps" just call it as follows:
\begin{quote}
\begin{verbatim}
c.writetofile("test")
\end{verbatim}
\end{quote}


\subsection{Methods}



The \verb|canvas| class provides the following methods:

\medskip
\begin{tabularx}
  {\linewidth}
  {>{\hsize=.85\hsize}X>{\raggedright\arraybackslash\hsize=1.15\hsize}X}
  \texttt{canvas} method & function \\
  \hline
  \texttt{bbox()} &
  Returns the bounding box enclosing all elements of the canvas.\\
  \texttt{draw(path, *styles)} & 
  Draws the given \texttt{path} on the canvas, \textit{i.e.}\
  \texttt{insert}s it together with the necessary \texttt{newpath},
  \texttt{stroke} sequence, applying the given \texttt{styles}. Styles
  can either be instances of \texttt{canvas.PSAttr} or
  \texttt{canvas.PathDeco}
  (or subclasses thereof).\\
  \texttt{fill(path, *styles)} &
  Fills the given \texttt{path} on the canvas, \textit{i.e.}\
  \texttt{insert}s it together with the necessary \texttt{newpath},
  \texttt{fill} sequence, applying the given \texttt{styles}. Styles can
  either be instances of \texttt{canvas.PSAttr} (or subclasses therof).\\
  \texttt{drawfilled(path, *styles)} &
  Draws and fills the given \texttt{path} on the canvas (\textit{i.e.}\
  \texttt{insert}s it together with the necessary \texttt{newpath},
  \texttt{gsave}, \texttt{stroke}, \texttt{grestore}, \texttt{fill} sequence)
  applying the given \texttt{styles}. Styles can either be instances of
  \texttt{canvas.PSAttr} (or subclasses thereof).\\
  \texttt{insert(PSOps, *styles)} &
  Insert one ore more instances of the class \texttt{base.PSOp} in the
  canvas applying the given \texttt{styles}.  Styles have to be instances
  of the class \texttt{canvas.PSAttr} or derived classes thereof.\\
  \texttt{set(*styles)} &
  Sets the given \texttt{styles} (instances of \texttt{canvas.PSAttr} or
  subclasses) for the rest of the canvas.\\
    \texttt{writetofile(filename, 
      \newline\phantom{writetofile(}paperformat=None, 
      \newline\phantom{writetofile(}rotated=0,
      \newline\phantom{writetofile(}fittosize=0, 
      \newline\phantom{writetofile(}margins="1 t cm")} &
  Writes the canvas to \texttt{filename}. Optionally a
  \texttt{paperformat} can be specified, in which case the output will
  be centered with respect to the corresponding size using the given
  \texttt{margin}. See \texttt{canvas.\_paperformats} for a list of
  known paper formats . Use \texttt{rotated}, if you want to center on
  a $90^\circ$ rotated version of the respective paper format. If
  \texttt{fittosize} is set, the output is additionally scaled to the
  maximal possible size.
\end{tabularx} 
\medskip








%%% Local Variables:
%%% mode: latex
%%% TeX-master: "manual.tex"
%%% End:
